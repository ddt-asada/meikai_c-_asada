/*演習8-15
 * 文字列s1の中に含まれる最も先頭に位置する文字列s2の先頭文字へのポインタを返す関数を作成。
 * 作成日：2017年5月12日
 * 作成者：浅田　知嗣
 */

#include <iostream>
//文字列処理関数を提供するヘッダ。
#include <cstring>

using namespace std;

//関数宣言。
const char* str_match(char* s1, char* s2);

int main()
{
	char	s1[] = "abcabcdefg";	//探す対象となる配列。

	char	s2[] = "abcd";			//探す文字列。

	//目的の先頭文字へのポインタを返す。
	cout	<<"文字列の走査を行いました。結果は"	<<str_match(s1, s2)	<<"です。\n";

	//0を返す。
	return 0;
}

/*関数名：const char* str_match(char* s1, char* s2)
 * 文字列の大小関係を比較する関数。比較は文字コードに基づいて行う。
 * 引数char* s1：比較したい文字列。
 * 引数char* s2：比較したい文字列。
 * 返却値：目的の先頭文字へのポインタ。
 * 作成日：2017年5月12日
 * 作成者：浅田　知嗣
 */

const char* str_match(char* s1, char* s2)
{
	int	len1 = strlen(s1);		//文字列の長さを求める。

	int	len2 = strlen(s2);		//文字列の長さを求める。

	int	judge = 0;				//文字列を見つけた回数をカウントする。

	//文字列の全要素を走査する。途中で目的の文字を見つけた場合は次の判定へ移る。。
	for(int i = 0; i < len1; i++) {

		//目的の文字の先頭が見つかったとき、そこに文字列s2が含まれているか調べる。。
		if(s1[i] == s2[0]) {

			//文字列をs2と比較してすべて同じ数値であった場合その文字の先頭のポインタを返す。
			for(int j = 0; j < len2; j++) {

				//同じ文字を見つけたときにカウント。
				if(s1[i + j] == s2[j]) {

					judge++;	//見つけた回数をカウント。
				}
			}

			//もし見つけた回数が文字列s2の長さと一緒なら文字列s2が含まれいる箇所と判断し、その先頭のポインタを返す。
			if(judge == len2) {

				return &s1[i];
			}

			judge = 0;	//判定を初期化。
		}
	}

	//見つからなかったときはNULLを返す。。
	return NULL;
}
