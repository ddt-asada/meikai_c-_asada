/*演習8-19
 * 文字列としてあらわされた実数値をdouble型の実数に変換した値を返す関数を作成。
 * 作成日：2017年5月12日
 * 作成者：浅田　知嗣
 * 更新日：2017年5月15日
 * 更新者：浅田　知嗣
 * 更新日：2017年5月16日
 * 更新者：浅田　知嗣
 */

#include <iostream>
//文字列処理を行うライブラリ関数を提供するヘッダ。
#include <cstring>

using namespace std;

//関数宣言。
double str2double(const char* s);

int main()
{
	const char	s[] = "13.56";		//実数値に変換したい文字列。

	//実数値に変換して表示。
	cout	<<"実数値に変換しました。\n"	<<str2double(s)	<<'\n';

	//0を返す。
	return 0;
}

/*関数名：double str2double(const char* s)
 * 文字列として表された実数値をdouble型の実数に変換した値を返す関数。
 * 引数const char* s：実数値に変換したい文字列。
 * 返却値：文字列を実数値に変換した値。
 * 作成日：2017年5月12日
 * 作成者：浅田　知嗣
 * 更新日：2017年5月15日
 * 更新者：浅田　知嗣
 * 更新日：2017年5月16日
 * 更新者：浅田　知嗣
 */

double str2double(const char* s)
{
	int		dotPlace = 0;			//小数点が格納されていた要素を記憶するのに使用。最後の桁数を下げる回数。小数点が含まれていたかどうかの判定もしたいので-1で初期化。

	int		len = strlen(s);		//文字列の長さを取得し、文字列をやりくりする際の繰り返し回数に利用する。

	double	num = 0;				//整数値に変換したものを入力するための型。合計を求めるのに使うので0で初期化。

	int		dig = 1;				//計算用の変数。積算に使用するので影響が出ないように1で初期化。

	//次に、文字列を整数に変換するための繰り返しを行う。
	//走査用の文字列で0～9が含まれていないか一つ一つ確認する。
	for(int i = len -1; i >= 0; i--) {

		//数字文字があったとき。
		if(s[i] == '0') {
			//0の時は何もする必要がないので空文とする。
			;
		//1を見つけたとき。
		} else if (s[i] == '1') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}

			num += 1 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//2を見つけたとき。
		} else if (s[i] == '2') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}

			num += 2 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//3を見つけたとき。
		} else if (s[i] == '3') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}

			num += 3 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//4を見つけたとき。
		} else if (s[i] == '4') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}

			num += 4 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//5を見つけたとき。
		} else if (s[i] == '5') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}

			num += 5 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//6を見つけたとき。
		} else if (s[i] == '6') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}

			num += 6 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//7を見つけたとき。
		} else if(s[i] == '7') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}
			num += 7 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//8を見つけたとき。
		} else if (s[i] == '8') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}
			num += 8 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//9を見つけたとき。
		} else if (s[i] == '9') {
			//この時、小数点がすでに見つかっているかどうかでさらに分岐。最後に桁数を合わせる都合上、10を何乗するかが変わってくるので。
			//すでに見つかっていた場合。
			if(i > dotPlace) {

				//その文字の桁数に対応して10のi+1乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int k = len - 1; k >= i; k--) {

					dig *= 10;		//10のi+1乗を求める。先ほどの考えに則り一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。
				}
			} else {
				//その文字の桁数に対応して10のi乗する。
				//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}
			}

			num += 9 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//小数点が見つかった場合には小数点の位置を記憶するともに、数字文字が見つかったと判定する。
		} else if (s[i] == '.') {

			dotPlace = i;	//格納場所を記憶。

		//最後のループでマイナスを見つけたとき。
		} else if (s[0] == '-' && i == 0) {

				num = -num;	//マイナスに変換する。

		//数字文字以外（ループの途中にマイナスが含まれていた場合も含む）は整数値に変換できないと判断する。
		} else {

			num = 0;	//計算値を0にリセット。

			i =  0;	//強制的にループを抜ける。
		}
	}
	//小数点があったかどうかを判定する。もしあった場合にはその場所に応じて10で割って桁数をそろえる。
	if(dotPlace >= 0) {

		//桁数を下げるための繰り返し。
		for(int i = len; i > dotPlace; i--) {

			num /= 10;		//10で割る。

		}
	}

	//最後に、求めた整数値を返す。
	return num;
}
