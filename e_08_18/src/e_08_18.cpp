/*演習8-18
 * 文字列として表された整数値をint型の整数値に変換した値を返す関数。
 * 作成日：2017年5月12日
 * 作成者：浅田　知嗣
 * 更新日：2017年5月13日
 * 更新者：浅田　知嗣
 * 更新日：2017年5月15日
 * 更新者：浅田　知嗣
 * 更新日：2017年5月16日
 * 更新者：浅田　知嗣
 */

#include<iostream>
//文字列処理を行うライブラリ関数を提供するヘッダ。
#include <cstring>

using namespace std;

//関数宣言。
int str2int(const char* s);

int main()
{
	const char		s[] = "123136";	//intに変換したい文字列を入力。

	//変換する関数を呼び出し、変換した整数値を表示。
	cout	<<"整数値に変換しました。"	<<str2int(s)	<<'\n';

	//0を返す。
	return 0;
}

/*関数名：int str2int(const char* s)
 * 引数const char* s：変換したい文字列。
 * 返却値：文字列を整数値に変換した値。
 * 作成日：2017年5月12日
 * 作成者：浅田　知嗣
 * 更新日：2017年5月13日
 * 更新者：浅田　知嗣
 * 更新日：2017年5月15日
 * 更新者：浅田　知嗣
 * 更新日：2017年5月16日
 * 更新者：浅田　知嗣
 */

int str2int(const char* s)
{
	int		len = strlen(s);

	int		num1 = 0;				//整数値に変換したものを入力するための型。合計を求めるのに使うので0で初期化。

	int		dig = 1;				//計算用の変数。積算に使用するので影響が出ないように1で初期化。

	//文字列を走査する。
	for(int i = len - 1; i >= 0; i--) {

		//数字文字があったとき。
		if(s[i] == '0') {

			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 0 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//1を見つけたとき。
		} else if (s[i] == '1') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 1 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//2を見つけたとき。
		} else if (s[i] == '2') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 2 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//3を見つけたとき。
		} else if (s[i] == '3') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
				for(int j = len - 1; j > i; j--) {

					dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

				}

			num1 += 3 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//4を見つけたとき。
		} else if (s[i] == '4') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 4 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//5を見つけたとき。
		} else if (s[i] == '5') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 5 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//6を見つけたとき。
		} else if (s[i] == '6') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 6 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//7を見つけたとき。
		} else if(s[i] == '7') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 7 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//8を見つけたとき。
		} else if (s[i] == '8') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 8 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//9を見つけたとき。
		} else if (s[i] == '9') {
			//その文字の桁数に対応して10のi乗する。
			//桁数の考え方としては、配列の最後尾から先頭へ向かって1桁目2桁目とする。
			for(int j = len - 1; j > i; j--) {

				dig *= 10;		//10のi乗を求める。先ほどの考えにのっとり一番後ろは1桁なのでそのまま（このループに突入しない）、2桁目以降には10をかけていく。

			}

			num1 += 9 * dig;	//見つけた数字と桁数に応じて10のi乗したものを合計していくことにより、整数に変換していく。

			dig = 1;			//計算に使った値をリセットする。

		//最後のループでマイナスを見つけたとき。
		} else if (s[0] == '-' && i == 0) {

			num1 = -num1;	//マイナスに変換する。

		//数字文字以外（ループの途中にマイナスが含まれていた場合も含む）は整数値に変換できないと判断する。
		} else {

			num1 = 0;	//計算値を0にリセット。

			i =  0;	//強制的にループを抜ける。
		}
	}

	//もとめた整数値を返す。
	return num1;
}
